In this project, we sought to be able to calculate and identify the shortest path between two locations on a road network. We used the City of Oldenburg, Germany as our road network, with data from the University of Utah.
We had two parsing functions, parseE and parseN, which parse the data for the edges and the node coordinate information, respectively. Data correction is included to make sure the nodes and edges form a coherent network. After parsing, we will have an edge list and a node-coordinate list, as well as an adjacency matrix generated from the edge list. We have a series of small tests (tests 3-9) which check if a value for a specific index is correct (ie, test 6 checks if the distance is correct for a specific edge in the edge list).
We also had a Dijkstra’s Shortest Path Algorithm. This algorithm worked by taking as input an adjacency matrix representing the graph’s nodes and its weighted edges. It functions first by generating a shortest path tree from a user-defined root and then recursively backtracking through that tree to find the shortest path from the root to its user-defined destination node. It returns a vector containing the list of nodes traversed on the shortest path and also updates the private dist_ variable with the distance traveled along the shortest path. We tested its functionality by passing in the adjacency matrix of a simple graph shown below and testing to find the shortest distance and the shortest path between two nodes (tests 15 and 16). Shown here is the path generated between nodes 0 “A” and 5 “F”, which one can visually identify is correct.

![image](/markdownimages/dijkstrasmall.jpg)

![image](/markdownimages/dijkstratests.png)

This can also be run on the Oldenburg data and here is the output it gives for the path between nodes 0 and 61.

![image](/markdownimages/dijkstrapath.png)

We also had a Depth First Traversal algorithm. We tested this with 3 checks, based on set input files which we know the correct traversal of. First we check that the correct number of nodes are traversed, then we check to make sure no nodes are repeated in the traversal, and finally we check to see that each step on the traversal is correct. Having these unit tests was very useful in developing this algorithm. Shown below is the DFS ran on our actual dataset (just the first ten nodes).

![image](/markdownimages/DFSpath.png)

We also had our graphical output algorithm, which can output a visual representation of a graph with or without a path highlighted. In order to create a sense of diagonals being drawn we essentially use the ratio between the distances needed to travel in x direction to y direction and work out which distance is the higher one. Then we paint an amount, equal to the said ratio of pixels in the direction of the larger distance for every one pixel painted in the dimension of the smaller distance until we reach the coordinates of the other node. We stop traveling in a certain direction once the coordinate of the destination in that dimension has been reached, which sometimes means that there is just a horizontal or vertical component. Since the algorithm does not take into account the actual shape of the road as it is impossible to do so from the given information sometimes there are intersections between the ’roads’ when there should not be. The nodes are painted over after the edges have been painted as if it was the other way around, edges might paint over the nodes. The algorithm with the path can only be run after the algorithm without the path has been run as it uses the information from the said algorithm to paint its own picture and all of the nodes have to be repainted again as they might be painted over by the edges. We tested it with a simple wheel graph and visually checked the output, then putting in a designated path and seeing that this too appears correctly on the graph. These pictures are shown below.

![image](/markdownimages/beegsnowflake.png)

![image](/markdownimages/beegsnowflakered.png)

Here is the road network of Oldenburg generated by this algorithm.

![image](/markdownimages/output.png)

We also have our overall test which can be run on any dataset in this format and calculates the shortest path between two given input nodes and outputs this path in red on the image of the road network. Look at the far left side on the middle of the y-axis to see that there is a red line marking our shortest path.

![image](/markdownimages/outD.png)


This was a fun and interesting project. We succeeded in seeing if we could generate and represent the shortest path on a road network on a graphical output. Our efforts to actually highlight the road led us down an interesting “path.” Our data only represents the positions of the nodes and the distance of connections between two nodes. To actually highlight the route, we needed to generate a close representation of the roads themselves. This led to the graphing algorithms which use simply node positions and the distances between them to generate lines representing the roads between nodes. We were very surprised and glad to discover that this graphical output is almost indistinguishable from the actual road map of the City of Oldenburg. It was very gratifying to see all the algorithms we put in turn into an actual bright red path leading us through the city.
	
